/* Copyright (c) 2015, Thomas Lang. All rights reserved.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef __AVL__
#define __AVL__

#include <cstddef>
#include <iostream>

#include "node.h"

using std::cout;
using std::endl;

/*
 * Implementation of an AVL tree.<p>
 * An AVL tree is a binary tree named after its inventors Georgi Maximowitsch 
 * <strong>A</strong>delson-<strong>V</strong>elski and Jewgeni Michailowitsch
 * <strong>L</strong>andis. This kind of tree is a so called 
 * <em>self-balancing</em> tree, that is always as balanced as possible, so
 * such a tree cannot get degenerated by insertion or deletions of nodes.
 * This in advance guarantees, that search operations, insertions, deletions
 * <em>always</em> run in <code>O(log n)</code> with <code>n</code> as the 
 * number of nodes in the tree.
 *
 * @author Thomas Lang
 * @version 1.0, 2015-07-27
 *
 * @param <T> 
 *     Generic type where all types can be put in as long as the comparison
 *     operation is defined.
 * @see <a href="https://en.wikipedia.org/wiki/AVL_tree">AVLs on Wikipedia</a>
 */
template <typename T>
class AVLTree {
    /*
     * Note that you can find the documentation of only declared methods 
     * directly above their implementation in 'avl.tpp'.
     */

    public:
        /* Indicator that nothing changed to the balance of the tree. */
        static const int NO_CHANGE;

        /* Indicator that the tree is 'one more heavy' on the right side. */
        static const int REBAL_ONE_POS;

        /* Indicator that the tree is 'one more heavy' on the left side. */
        static const int REBAL_ONE_NEG;

        /* Indicator that the tree is 'two more heavy' on the right side. */
        static const int REBAL_TWO_POS;

        /* Indicator that the tree is 'two more heavy' on the left side. */
        static const int REBAL_TWO_NEG;
    private:
        /* The number of elements stored in the tree. */
        int size;

        /* The root node of the tree. */
        Node<T> *root;
    public:
        /* Creates a new instance of this class and initializes it. */
        AVLTree() : size(0), root(NULL) {}

        ~AVLTree();
        bool contains(T value);
        bool insert(T value);
        bool remove(T value);
        Node<T> *get(T value);
        void clear();

        /*
         * Checks if the tree is empty (if it has no elements).
         *
         * @return Returns either {@code true} if the tree is empty, 
         *         {@code false} otherwise.
         */
        bool isEmpty() { return size == 0; }

        /*
         * Returns the total amount of nodes in the tree.
         *
         * @return Returns the total amount of nodes in the tree.
         */
        int getSize() { return size; }

        /*
         * Prints the tree.
         */
        void print() {
            if (isEmpty()) {
                cout << "(empty tree)" << endl;
                return;
            }
            root->print();
        }
    private:
        bool insert(Node<T>*, Node<T>*);
        Node<T> *get(Node<T>*, T);
        void rotate(Node<T>*, bool);
        void rotateLeft(Node<T>*);
        void rotateRight(Node<T>*);
        void deleteInternalNode(Node<T>*);
        void deleteNode(Node<T>*);
        void deleteTreeFromRoot(Node<T>*);
        Node<T>* findMaxOfMinNode(Node<T>*);
};

#include "avl.tpp"

#endif
