;;;; Copyright (c) 2015, Thomas Lang. All rights reserved.
;;;; 
;;;; This program is free software: you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation, either version 3 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program.  If not, see <http://www.gnu.org/licenses/>

(defconstant NO_CHANGE 0 
  "Indicator that nothing changed to the balance of the tree.")
(defconstant REBAL_ONE_POS 1 
  "Indicator that the tree is 'one more heavy' on the right side.")
(defconstant REBAL_TWO_POS 2
  "Indicator that the tree is 'two more heavy' on the right side.")
(defconstant REBAL_ONE_NEG -1
  "Indicator that the tree is 'one more heavy' on the left side.")
(defconstant REBAL_TWO_NEG -2
  "Indicator that the tree is 'two more heavy' on the left side.")

(defclass node ()
  ((value :accessor value 
          :initarg :value
          :documentation "Single value hold by this node.")
   (left :accessor left 
         :initarg :left 
         :initform nil
         :documentation "Pointer to this node's left child.")
   (right :accessor right 
          :initarg :right 
          :initform nil
          :documentation "Pointer to this node's right child.")
   (parent :accessor parent 
           :initarg :parent 
           :initform nil
           :documentation "Pointer to this node's parent node."))
  :documentation 
  " Implementation of a single node of an AVL tree.<p>
    Such a node holds a single value and references to both child nodes and
    to its parent node. Furthermore, such a node has a balance, that depends
    on the nodes' height in the tree. This balance value is essential for
    tree rotations.
   
    @author Thomas Lang
    @version 1.0, 2015-08-21
    @see AVLTree#rotate(Node, boolean)
    @see #getBalance()"
)

(defmethod get-balance ((n node))
  " Returns the <em>balance</em> of this node, which is simply the
    height of its right sub tree minored by the height of the left
    sub tree.<p>
    This value is essential for tree rotations that will stabilize the
    tree after every operation if necessary.
   
    @param n
            The node whose balance should be computed.
    @return Returns the balance of this node.
    @see AVLTree#rotate(Node, boolean)"
  (let ((rn (null (right n)))
        (ln (null (left n))))
    (if (and rn ln) 0
      (let ((rbal (if rn 0 (get-height (right n))))
            (lbal (if ln 0 (get-height (left n)))))
        (- rbal lbal)))))

(defmethod get-height ((n node))
  " Returns the height of this node in the surrounding tree.
   
    @param n
            The node whose height should be computed.
    @return Returns the height of this node in the surrounding tree."
  (let ((rn (null (right n)))
        (ln (null (left n))))
    ;; Note that for calculating purposes the minimum height in a
    ;; tree is 1, not 0.
    (if (and rn ln) 1
      (let ((rh (if rn 0 (get-height (right n))))
            (lh (if ln 0 (get-height (left n)))))
        (+ 1 (max rh lh))))))

(defmethod print-node ((n node))
  "Prints out the passed node including all children.

   @param n
           The node to print."
  (if (not (null (left n)))
      (progn
        (princ "(")
        (print-node (left n))
        (princ ")")))

  (princ "[")
  (princ (value n))
  (princ "]")

  (if (not (null (right n)))
      (progn
        (princ "(")
        (print-node (right n))
        (princ ")"))))



(defclass avltree ()
  ((size :accessor size 
         :initform 0 
         :initarg :size
         :documentation "The number of elements stored in the tree.")
   (root :accessor root 
         :initform nil 
         :initarg :root
         :documentation "The root node of the tree."))
  :documentation
  "Implementation of an AVL tree.<p>
  An AVL tree is a binary tree named after its inventors Georgi Maximowitsch 
  <strong>A</strong>delson-<strong>V</strong>elski and Jewgeni Michailowitsch
  <strong>L</strong>andis. This kind of tree is a so called 
  <em>self-balancing</em> tree, that is always as balanced as possible, so
  such a tree cannot get degenerated by insertion or deletions of nodes.
  This in advance guarantees, that search operations, insertions, deletions
  <em>always</em> run in <code>O(log n)</code> with <code>n</code> as the 
  number of nodes in the tree.
 
  @author Thomas Lang
  @version 1.0, 2015-08-21
  @see <a href="https://en.wikipedia.org/wiki/AVL_tree">AVLs on Wikipedia</a>"
)


(defmethod is-empty ((tree avltree))
  " Checks if the tree is empty (if it has no elements).
   
    @param tree
            The tree to check if empty or not.
    @return Returns either {@code true} if the tree is empty, {@code false}
            otherwise."
  (null (root tree)))

(defmethod insert ((tree avltree) value)
  "Inserts a new node with a value of {@code value} into this AVL tree.<p>
   The insertion itself is just as like the insertion into a normal binary
   search tree, but after this was successfully performed, a tree rotation
   is made if necessary, so the tree is in balance again.
   
   @param tree
           The tree to insert into.
   @param value
           The value of the new node to insert.
   @return Returns {@code true} if the insertion was successful, 
           {@code false} otherwise.
   @see rotate(Node<T>, boolean)"
  (let ((n (make-instance 'node :value value))
        (success T))
    (if (is-empty tree)
        (setf (root tree) n)
      (setf success (insert-rec (root tree) n)))
    (if success (+ (size tree) 1))
    (rotate tree n nil)
    success))

(defmethod insert-rec ((current node) (n node))
  " Performs the recursive insertion into the tree.<p>
    This function works <em>exactly</em> like the insertion into a binary
    search tree and because of that, its runtime lies in {@code O(log n)} 
    where {@code n} is the number of elements in the tree.
   
    @param current
              The traversal node used for recursion, that should not be 
              {@code null}.
    @param n
              The new node to insert, that should not be {@code null}.
    @return Returns {@code true} if the insertion was successful,
            {@code false} otherwise."
  (let ((newvalue (value n))
        (curvalue (value current)))
    (cond ((< newvalue curvalue)
           (if (null (left current))
               (progn
                 (setf (left current) n)
                 (setf (parent n) current))
             (insert-rec (left current) n)))
          ((> newvalue curvalue)
           (if (null (right current))
               (progn
                 (setf (right current) n)
                 (setf (parent n) current))
             (insert-rec (right current) n)))
          (t nil))) ; no duplicates allowed
  T)

(defmethod rotate ((tree avltree) (n node) deletion)
  " Performs a tree rotation around the node {@code node}.<p>
    This method performs a tree rotation around the passed node if 
    necessary. A rotation must only be performed, if the balance of the
    node reaches a certain level. The exact behaviour is different, if 
    it's a rotation for an insertion or if it's a rotation after deleting 
    a node.:
    
    <ul>
    <li>
    If the rotation will be made after an insertion:
      <ol>
        <li>If the balance is zero, nothing changed to the tree, so there
            need not to be any rotation taken.</li>
        <li>If the balance is &plusmn; 1, then we must check the balance
            of the parent node.</li>
        <li>If the balance is &plusmn; 2, then we perform a rotation
            depending on this balance and the balance of the previous child.
        </li>
      </ol>
    </li>
    <li>
    If the rotation will be made after the deletion of a node:
      <ol>
        <li>If the balance was zero, we must check the balance of the parent
            node.</li>
        <li>If the balance was &plusmn; 1, then nothing changed on the 
            balances of the tree, so no rotation will be performed.</li>
        <li>If the balance was &plusmn; 2, then we perform a rotation 
            depending on that balance and the one of the deleted node.</li>
      </ol>
    </li>
    </ul>
   
    Note that as a special property of the <em>AVL</em> tree, the balances 
    of every node <em>always</em> lies in the range of 
    {@code -1 &leq; x &leq; 1} with {@code x} denoting the balance.
   
    @param tree
             The tree where the rotation takes place in.
    @param n
             The node to rotate over, which should not be {@code null}.
    @param deletion
             Indicator if this is a rotation after an insertion or after
             a deletion of the node.
    @see <a href="https://en.wikipedia.org/wiki/AVL_tree#Insertion">
         Insertions and Deletions in AVL trees on Wikipedia
         </a>"

  (if (and
       (eql (root tree) n)
       (null (left n))
       (null (right n)))
      ;; If we have the pure root node here, which does not have any
      ;; children in this pure case, we need not to rotate anything.
      T

    ;; Note that if we do not start with the root here, the pointer to the
    ;; parent node of the passed one is always not null.
    (let* ((par (if deletion n (parent n)))
           (balance (if (null par) 0 (get-balance par))))
      (cond ((= balance NO_CHANGE)
             (if (and deletion (not (null (parent par))))
                 (rotate tree (parent n) deletion)
               T))
            ((or (= balance REBAL_ONE_NEG) (= balance REBAL_ONE_POS))
             (if (and (not deletion) (not (null (parent par))))
                 (rotate tree (parent n) deletion)
               (if deletion T)))
            (T (let ((lbal (if (null (left par)) 0 (get-balance (left par))))
                     (rbal (if (null (right par)) 0 (get-balance (right par)))))
              
                 ;;Performing rotations depending on the balances of the nodes:
                 ;;
                 ;; (1) If the node parents balance is +2:
                 ;;
                 ;;   (1.1) If the balance of the right child is +1, we perform a 
                 ;;         'left' rotation, so the right child will become the 
                 ;;         parent of its former parent node.
                 ;;
                 ;;   (1.2) If the balance of the right child is -1, we perform a
                 ;;         'right-left' rotation, what is basically a 'right'
                 ;;         rotation on the right child followed by a 'left' 
                 ;;         rotation on the parent node.
                 ;;
                 ;; (2) If the node parents balance is -2:
                 ;;
                 ;;   (2.1) If the balance of the left child is +1, we perform a
                 ;;         'left-right' rotation, what is basically a 'left'
                 ;;         rotation on the left child followed by a 'right'
                 ;;         rotation on the parent node.
                 ;;
                 ;;   (2.2) If the balance of the left child is -1, we perform a
                 ;;         'right' rotation, so the left child will become the
                 ;;         parent of its former parent node.
                 (if (= balance REBAL_TWO_POS)
                     (if (= rbal REBAL_ONE_POS)
                         (rotate-left tree par)
                       (if (= rbal REBAL_ONE_NEG)
                           (progn
                             (rotate-right tree (right par))
                             (rotate-left tree par))))
                   (if (= balance REBAL_TWO_NEG)
                       (if (= lbal REBAL_ONE_POS)
                           (progn
                             (rotate-left tree (left par))
                             (rotate-right tree par))
                         (if (= lbal REBAL_ONE_NEG)
                             (rotate-right tree par))))))))))
  T
)

(defmethod rotate-left ((tree avltree) (n node))
  " Performs a simple 'left' rotation around the passed node.
   
    @param tree
             The tree where the rotation takes place in.
    @param n
             The node to rotate around, which should not be {@code null}."
  (let* ((par (parent n))
        (rig (right n))
        (riglef (left rig)))
    (progn
      (setf (parent n) rig)
      (setf (right n) riglef)
      (setf (parent rig) par)
      (setf (left rig) n)
      (if (not (null riglef))
          (setf (parent riglef) n))
      (cond ((null par) (setf (root tree) rig))
            ((eql n (left par)) (setf (left par) rig))
            (T (setf (right par) rig)))))
  T
)

(defmethod rotate-right ((tree avltree) (n node))
  " Performs a simple 'right' rotation around the passed node.
   
    @param tree
             The tree where the rotation takes place in.
    @param n
             The node to rotate around, which should not be {@code null}."
  (let* ((par (parent n))
        (lef (left n))
        (lefrig (right lef)))
    (progn
      (setf (parent n) lef)
      (setf (left n) lefrig)
      (setf (parent lef) par)
      (setf (right lef) n)
      (if (not (null lefrig))
          (setf (parent lefrig) n))
      (cond ((null par) (setf (root tree) lef))
            ((eql n (right par)) (setf (right par) lef))
            (T (setf (left par) lef)))))
  T
)

(defmethod get-node ((tree avltree) value)
  " Retrieves the node with the passed {@code value} from the tree.
   
    @param tree
            The tree to search for the passed value in.
    @param value
            The value of the node to return.
    @return Returns the node with the passed {@code value} from the tree,
            or {@code null} if either the tree is empty (has no elements) or
            if there is no such node in the tree."
  (if (is-empty tree)
      nil
    (get-rec (root tree) value)))

(defmethod get-rec ((current node) value)
  " Retrieves the node with the passed {@code value} from the tree 
    recursively.
   
    @param current
              The traversal node used for recursion, which should not be
              {@code null}.
    @param value
              The value of the node to retrieve.
    @return Returns either {@code true} if the node with the passed 
            {@code value} was found successfully or {@code null} otherwise."
  (let ((curvalue (value current)))
    (cond ((eql value curvalue) current) ; We found the node successfully!
          ((and (< value curvalue) (not (null (left current))))
           (get-rec (left current) value))
          ((and (> value curvalue) (not (null (right current))))
           (get-rec (right current) value))
          (T nil)))) ; No such node found.

(defmethod contains ((tree avltree) value)
  " Checks if the tree contains a node with the value {@code value}.
   
    @param tree
            The tree that possibly contains the passed value.
    @param value
            The value of the node to check.
    @return Returns either {@code true} if the tree contains such a node, or
            {@code false} if not."
  (not (null (get-node tree value))))


(defmethod remove-node ((tree avltree) value)
  " Removes the node with the passed {@code value} from the tree if
    existent. As a speciality of an AVL tree, this operation also runs
    in {@code O(log n)} with {@code n} denoting the number of nodes in the
    tree. Furthermore, even after a deletion of a node the tree will be 
    rotated if necessary.
   
    @param tree
            The tree to remove the value in.
    @param value
            The value of the node to delete.
    @return Returns either {@code true} if the node was successfully deleted
            or {@code false} otherwise."
  (if (is-empty tree)
      nil
    (let ((delnode (get-node tree value)))
      (if (null delnode)
          nil ; No node with 'value' found.
        (let ((par (parent delnode)))
          (progn
            (cond ((eql value (value (root tree))) 
                   (deleteInternalNode (root tree)))
                  ((and 
                    (not (null (left delnode)))
                    (not (null (right delnode))))
                   (deleteInternalNode delnode))
                  (T (deleteNode delnode)))
            (- (size tree) 1)
            (if (not (null par))
                (rotate tree par T)))))))
  T
)

(defmethod find-max-of-min ((n node))
  " Finds the node with the maximum value in the left sub tree of 
    the passed node.
   
    @param n
            The node that marks the root of the corresponding sub tree which
            should not be {@code null}.
    @return Returns the node with the maximum value in the left sub tree
            of the passed node."
  (let ((leftchild (left n)))
    (loop while (not (null (right leftchild))) do
          (setf leftchild (right leftchild)))
    leftchild))

(defmethod deleteInternalNode ((n node))
  " Deletes a node internal to the tree (no leaf) by swapping it with the
    node with a maximum value but still below the value of the node.
   
    @param n
             The internal node to delete which should not be {@code null}."
  (let ((maxofmin (find-max-of-min n)))
    (if (null maxofmin)
        nil
      (progn
        (setf (value n) (value maxofmin))
        (deleteNode maxofmin))))
  T)

(defmethod deleteNode ((n node))
  " Deletes a node from the tree, mainly leaf nodes.
   
    @param n
             The node to delete, which should not be {@code null}."
  (let* ((par (parent n))
         (lef (left n))
         (rig (right n))
         (pri (right par))
         (right-child (and (not (null pri)) (eql (value pri) (value n)))))

    ;; Please note that we need not to check if 'parent' is null here,
    ;; because this can only happen if 'node' is the root, but this special
    ;; case is already recognized in the methode 'remove'.
    (cond ((and (null (left n)) (null (right n)))
           (if right-child
               (setf (right par) nil)
             (setf (left par) nil)))
          ((not (null (left n)))
           (progn
             (if right-child
                 (setf (right par) lef)
               (setf (left par) lef))
             (setf (parent lef) par)))
          (T (progn
               (if right-child
                   (setf (left par) rig)
                 (setf (right par) rig))
               (setf (parent rig) par))))
    (setf (parent n) nil))
  T
)

(defmethod clear ((tree avltree))
  "Clears the tree.
 
   @param tree
            The tree to clear."
  (setf (root tree) nil)
  (setf (size tree) 0)
  T)

(defmethod print-tree ((tree avltree))
  "Prints out the passed tree.

   @param tree
            The tree to print."
  (if (is-empty tree)
      (print "(empty tree)")
    (print-node (root tree)))
  T)


(defun main ()
  "Main (testing) function."
  (princ "Creating tree ... ")
  (setf tree (make-instance 'avltree))
  (princ "done.")
  (terpri)

  (princ "Provocating rotation ... ")
  (insert tree -42)
  (insert tree 7)
  (insert tree 999)
  (princ "done.")
  (terpri)
  (princ "Actual tree:")
  (terpri)
  (print-tree tree)
  (terpri)

  (princ "Provocating second rotation ... ")
  (insert tree 10)
  (insert tree 144)
  (princ "done.")
  (terpri)
  (princ "Actual tree:")
  (terpri)
  (print-tree tree)
  (terpri)

  (princ "Provocating third rotation and root changing ... ")
  (insert tree 9)
  (princ "done.")
  (terpri)
  (princ "Actual tree:")
  (terpri)
  (print-tree tree)
  (terpri)

  (princ "Does the tree contain '999'? -> ")
  (if (contains tree 999)
      (princ "Yes")
    (princ "No"))
  (terpri)

  (princ "Deleting root ... ")
  (remove-node tree 10)
  (princ "done.")
  (terpri)
  (princ "Deleting nodes '-42', '7' ... ")
  (remove-node tree -42)
  (remove-node tree 7)
  (princ "done.")
  (terpri)

  (princ "Does the tree contain '-42'? -> ")
  (if (contains tree -42)
      (princ "Yes")
    (princ "No"))
  (terpri)

  (princ "Actual tree:")
  (terpri)
  (print-tree tree)
  (terpri)

  (princ "Clearing tree ... ")
  (clear tree)
  (princ "done.")
  (terpri)
  (princ "Tree should be empty now: ")
  (if (is-empty tree)
      (princ "Yes")
    (princ "No"))
  (terpri)
)

;;; Invoking the main function.
(main)
