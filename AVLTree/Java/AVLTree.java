/* Copyright (c) 2015, Thomas Lang. All rights reserved.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

import java.util.Queue;
import java.util.LinkedList;

/**
 * Implementation of an AVL tree.<p>
 * An AVL tree is a binary tree named after its inventors Georgi Maximowitsch 
 * <strong>A</strong>delson-<strong>V</strong>elski and Jewgeni Michailowitsch
 * <strong>L</strong>andis. This kind of tree is a so called 
 * <em>self-balancing</em> tree, that is always as balanced as possible, so
 * such a tree cannot get degenerated by insertion or deletions of nodes.
 * This in advance guarantees, that search operations, insertions, deletions
 * <em>always</em> run in <code>O(log n)</code> with <code>n</code> as the 
 * number of nodes in the tree.
 *
 * @author Thomas Lang
 * @version 1.0, 2015-07-25
 *
 * @param <T> 
 *     Generic type where all subtypes of <code>Object</code> can be set
 *     in, as long as this type implements the <code>Comparable</code>
 *     interface.
 * @see <a href="https://en.wikipedia.org/wiki/AVL_tree">AVLs on Wikipedia</a>
 */
public class AVLTree<T extends Comparable<T>> {

    /** Indicator that nothing changed to the balance of the tree. */
    private static final int NO_CHANGE = 0;

    /** Indicator that the tree is 'one more heavy' on the right side. */
    private static final int REBAL_ONE_POS = 1;

    /** Indicator that the tree is 'one more heavy' on the left side. */
    private static final int REBAL_ONE_NEG = -1;

    /** Indicator that the tree is 'two more heavy' on the right side. */
    private static final int REBAL_TWO_POS = 2;

    /** Indicator that the tree is 'two more heavy' on the left side. */
    private static final int REBAL_TWO_NEG = -2;

    /** The number of elements stored in the tree. */
    private int size;

    /** The root node of the tree. */
    private Node<T> root;

    /**
     * Inserts a new node with a value of {@code value} into this AVL tree.<p>
     * The insertion itself is just as like the insertion into a normal binary
     * search tree, but after this was successfully performed, a tree rotation
     * is made if necessary, so the tree is in balance again.
     *
     * @param value
     *           The value of the new node to insert.
     * @return Returns {@code true} if the insertion was successful, 
     *         {@code false} otherwise.
     * @see rotate(Node<T>, boolean)
     */
    public boolean insert(T value) {
        final Node<T> node = new Node<T>(value);
        boolean success = true;

        if (isEmpty()) {
            root = node;
        } else {
            success = insert(root, node);
        }

        if (success) {
            ++size;
        }

        rotate(node, false);
        return success;
    }

    /**
     * Performs the recursive insertion into the tree.<p>
     * This function works <em>exactly</em> like the insertion into a binary
     * search tree and because of that, its runtime lies in {@code O(log n)} 
     * where {@code n} is the number of elements in the tree.
     *
     * @param current
     *           The traversal node used for recursion, that should not be 
     *           {@code null}.
     * @param newNode
     *           The new node to insert, that should not be {@code null}.
     * @return Returns {@code true} if the insertion was successful,
     *         {@code false} otherwise.
     */
    private boolean insert(Node<T> current, Node<T> newNode) {
        assert newNode != null : "Null node passed.";
        assert current != null : "Null node passed.";

        final T newValue = newNode.value;
        final T curValue = current.value;

        if (newValue.compareTo(curValue) < 0) {
            if (current.left == null) {
                current.left = newNode;
                newNode.parent = current;
            } else {
                return insert(current.left, newNode);
            }
        } else if (newValue.compareTo(curValue) > 0) {
            if (current.right == null) {
                current.right = newNode;
                newNode.parent = current;
            } else {
                return insert(current.right, newNode);
            }
        } else {
            /* No duplicates allowed. */
            return false;
        }

        return true;
    }

    /**
     * Performs a tree rotation around the node {@code node}.<p>
     * This method performs a tree rotation around the passed node if 
     * necessary. A rotation must only be performed, if the balance of the
     * node reaches a certain level. The exact behaviour is different, if 
     * it's a rotation for an insertion or if it's a rotation after deleting 
     * a node.:
     * 
     * <ul>
     * <li>
     * If the rotation will be made after an insertion:
     *   <ol>
     *     <li>If the balance is zero, nothing changed to the tree, so there
     *         need not to be any rotation taken.</li>
     *     <li>If the balance is &plusmn; 1, then we must check the balance
     *         of the parent node.</li>
     *     <li>If the balance is &plusmn; 2, then we perform a rotation
     *         depending on this balance and the balance of the previous child.
     *     </li>
     *   </ol>
     * </li>
     * <li>
     * If the rotation will be made after the deletion of a node:
     *   <ol>
     *     <li>If the balance was zero, we must check the balance of the parent
     *         node.</li>
     *     <li>If the balance was &plusmn; 1, then nothing changed on the 
     *         balances of the tree, so no rotation will be performed.</li>
     *     <li>If the balance was &plusmn; 2, then we perform a rotation 
     *         depending on that balance and the one of the deleted node.</li>
     *   </ol>
     * </li>
     * </ul>
     *
     * Note that as a special property of the <em>AVL</em> tree, the balances 
     * of every node <em>always</em> lies in the range of 
     * {@code -1 &leq; x &leq; 1} with {@code x} denoting the balance.
     *
     * @param node
     *          The node to rotate over, which should not be {@code null}.
     * @param deletion
     *          Indicator if this is a rotation after an insertion or after
     *          a deletion of the node.
     * @see <a href="https://en.wikipedia.org/wiki/AVL_tree#Insertion">
     *      Insertions and Deletions in AVL trees on Wikipedia
     *      </a>
     */
    private void rotate(Node<T> node, boolean deletion) {
        assert node != null : "Null node passed.";

        if ((node == root) && (node.left == null) && (node.right == null)) {
            /*
             * If we have the pure root node here, which does not have any
             * children in this pure case, we need not to rotate anything.
             */
            return;
        }

        /*
         * Note that if we do not start with the root here, the pointer to the
         * parent node of the passed one is always not null.
         */
        final Node<T> parent = deletion ? node : node.parent;
        final int balance = (parent == null) ? 0 : parent.getBalance();

        if (balance == NO_CHANGE) {
            if (deletion && (parent.parent != null)) {
                rotate(node.parent, deletion);
            } else {
                return;
            }
        } else if ((balance == REBAL_ONE_NEG) || (balance == REBAL_ONE_POS)) {
            if (!deletion && (parent.parent != null)) {
                rotate(node.parent, deletion);
            } else if (deletion) {
                return;
            }
        } else {
            final int lbal 
                = (parent.left == null) ? 0 : parent.left.getBalance();
            final int rbal 
                = (parent.right == null) ? 0 : parent.right.getBalance();

            /*
             * Performing rotations depending on the balances of the nodes:
             *
             * (1) If the node parents balance is +2:
             *
             *   (1.1) If the balance of the right child is +1, we perform a 
             *         'left' rotation, so the right child will become the 
             *         parent of its former parent node.
             *
             *   (1.2) If the balance of the right child is -1, we perform a
             *         'right-left' rotation, what is basically a 'right'
             *         rotation on the right child followed by a 'left' 
             *         rotation on the parent node.
             *
             * (2) If the node parents balance is -2:
             *
             *   (2.1) If the balance of the left child is +1, we perform a
             *         'left-right' rotation, what is basically a 'left'
             *         rotation on the left child followed by a 'right'
             *         rotation on the parent node.
             *
             *   (2.2) If the balance of the left child is -1, we perform a
             *         'right' rotation, so the left child will become the
             *         parent of its former parent node.
             */
            if (balance == REBAL_TWO_POS) {
                if (rbal == REBAL_ONE_POS) {
                    rotateLeft(parent);
                } else if (rbal == REBAL_ONE_NEG) {
                    rotateRight(parent.right);
                    rotateLeft(parent);
                }
            } else if (balance == REBAL_TWO_NEG) {
                if (lbal == REBAL_ONE_POS) {
                    rotateLeft(parent.left);
                    rotateRight(parent);
                } else if (lbal == REBAL_ONE_NEG) {
                    rotateRight(parent);
                }
            }
        }
    }

    /**
     * Performs a simple 'left' rotation around the node {@code node}.
     *
     * @param node
     *          The node to rotate around, which should not be {@code null}.
     */
    private void rotateLeft(Node<T> node) {
        assert node != null : "Null node passed.";

        Node<T> parent    = node.parent;
        Node<T> right     = node.right;
        Node<T> rightLeft = right.left;

        node.parent    = right;
        node.right     = rightLeft;

        right.parent   = parent;
        right.left     = node;

        if (rightLeft != null) {
            rightLeft.parent = node;
        }

        if (parent == null) {
            root = right;
        } else if (parent.left == node) {
            parent.left = right;
        } else {
            parent.right = right;
        }
    }

    /**
     * Performs a simple 'right' rotation around the node {@code node}.
     *
     * @param node
     *          The node to rotate around, which should not be {@code null}.
     */
    private void rotateRight(Node<T> node) {
        assert node != null : "Null node passed.";

        Node<T> parent    = node.parent;
        Node<T> left      = node.left;
        Node<T> leftRight = left.right;

        node.parent    = left;
        node.left      = leftRight;

        left.parent    = parent;
        left.right     = node;

        if (leftRight != null) {
            leftRight.parent = node;
        }

        if (parent == null) {
            root = left;
        } else if (parent.right == node) {
            parent.right = left;
        } else {
            parent.left = left;
        }
    }

    /**
     * Retrieves the node with the passed {@code value} from the tree.
     *
     * @param value
     *          The value of the node to return.
     * @return Returns the node with the passed {@code value} from the tree,
     *         or {@code null} if either the tree is empty (has no elements) or
     *         if there is no such node in the tree.
     */
    public Node<T> get(T value) {
        if (isEmpty()) {
            return null;
        } else {
            return get(root, value);
        }
    }

    /**
     * Retrieves the node with the passed {@code value} from the tree 
     * recursively.
     *
     * @param current
     *           The traversal node used for recursion, which should not be
     *           {@code null}.
     * @param value
     *           The value of the node to retrieve.
     * @return Returns either {@code true} if the node with the passed 
     *         {@code value} was found successfully or {@code null} otherwise.
     */
    private Node<T> get(Node<T> current, T value) {
        assert current != null : "Null node passed.";

        final T curValue = current.value;

        if (value.compareTo(curValue) == 0) {
            /* We found the node successfully! */
            return current;
        } else if ((value.compareTo(curValue) < 0) && (current.left != null)) {
            return get(current.left, value);
        } else if ((value.compareTo(curValue) > 0) && (current.right != null)) {
            return get(current.right, value);
        } else {
            /* We could not find anything matching. */
            return null;
        }
    }

    /**
     * Checks if the tree contains a node with the value {@code value}.
     *
     * @param value
     *         The value of the node to check.
     * @return Returns either {@code true} if the tree contains such a node, or
     *         {@code false} if not.
     */
    public boolean contains(T value) {
        return get(value) != null;
    }

    /**
     * Returns the total amount of nodes in the tree.
     *
     * @return Returns the total amount of nodes in the tree.
     */
    public int size() {
        return size;
    }

    /**
     * Removes the node with the passed {@code value} from the tree if
     * existent. As a speciality of an AVL tree, this operation also runs
     * in {@code O(log n)} with {@code n} denoting the number of nodes in the
     * tree. Furthermore, even after a deletion of a node the tree will be 
     * rotated if necessary.
     *
     * @param value
     *         The value of the node to delete.
     * @return Returns either {@code true} if the node was successfully deleted
     *         or {@code false} otherwise.
     */
    public boolean remove(T value) {

        if (isEmpty()) {
            return false;
        } 
        
        final Node<T> deleteableNode = get(value);

        if (deleteableNode == null) {
            /* No node with 'value' found. */
            return false;
        } else {
            
            Node<T> parent = deleteableNode.parent;

            if (value.compareTo(root.value) == 0) {
                deleteInternalNode(root);
            } else if ((deleteableNode.left != null) 
                    && (deleteableNode.right != null)) {
                deleteInternalNode(deleteableNode);
            } else {
                deleteNode(deleteableNode);
            }

            --size;

            if (parent != null) {
                rotate(parent, true);
            }

            return true;
        }
    }

    /**
     * Deletes a node internal to the tree (no leaf) by swapping it with the
     * node with a maximum value but still below the value of the {@code node}.
     *
     * @param node
     *          The internal node to delete which should not be {@code null}.
     */
    private void deleteInternalNode(Node<T> node) {
        assert node != null : "Null node passed.";

        Node<T> maxOfMin = findMaxOfMinNode(node);

        if (maxOfMin == null) {
            System.out.println("no max-min");
            return;
        }

        node.value = maxOfMin.value;
        deleteNode(maxOfMin);
    }

    /**
     * Deletes a {@code node} from the tree, mainly leaf nodes.
     *
     * @param node
     *          The node to delete, which should not be {@code null}.
     */
    private void deleteNode(Node<T> node) {
        assert node != null : "Null node passed.";

        Node<T> parent = node.parent;
        Node<T> left   = node.left;
        Node<T> right  = node.right;
        Node<T> pright = parent.right;
        Node<T> pleft  = parent.left;
        final boolean rightChild 
            = (pright != null) && (pright.value.compareTo(node.value) == 0);

        /*
         * Please note that we need not to check if 'parent' is null here,
         * because this can only happen if 'node' is the root, but this special
         * case is already recognized in the methode 'remove'.
         */

        if ((node.left == null) && (node.right == null)) {

            if (rightChild) {
                parent.right = null;
            } else {
                parent.left  = null;
            }

        } else if (node.left != null) {
            
            if (rightChild) {
                parent.right = left;
            } else {
                parent.left = left;
            }

            left.parent = parent;
        } else {

            if (rightChild) {
                parent.left = right;
            } else {
                parent.right = right;
            }

            right.parent = parent;
        }

        node.parent = null;
    }

    /**
     * Finds the node with the maximum value in the left sub tree of 
     * {@code node}.
     *
     * @param node
     *         The node that marks the root of the corresponding sub tree which
     *         should not be {@code null}.
     * @return Returns the node with the maximum value in the left sub tree
     *         of {@code node}.
     */
    private Node<T> findMaxOfMinNode(Node<T> node) {
        assert node != null : "Null node passed.";

        Node<T> leftChild = node.left;

        while (leftChild.right != null) {
            leftChild = leftChild.right;
        }

        return leftChild;
    }

    /**
     * Checks if the tree is empty (if it has no elements).
     *
     * @return Returns either {@code true} if the tree is empty, {@code false}
     *         otherwise.
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * Clears the tree.
     */
    public void clear() {
        root = null;
        size = 0;
    }

    /**
     * Returns a string representation of the entire tree.
     *
     * @return Returns a string representation of the entire tree.
     */
    @Override
    public String toString() {
        
        if (isEmpty()) {
            return "(empty tree)";
        }

        return root.toString();
    }

    /**
     * Implementation of a single node of an AVL tree.<p>
     * Such a node holds a single value and references to both child nodes and
     * to its parent node. Furthermore, such a node has a balance, that depends
     * on the nodes' height in the tree. This balance value is essential for
     * tree rotations.
     *
     * @author Thomas Lang
     * @version 1.0, 2015-07-25
     *
     * @param <T> Type parameter, where any sub type of {@code Object} can be 
     *            set in, as long as this type implements the 
     *            {@code Comparable} interface.
     * @see AVLTree#rotate(Node, boolean)
     * @see #getBalance()
     */
    static class Node<T extends Comparable<T>> {
        
        /** Single value hold by this node. */
        T value;

        /** Pointer to the left child of this node. */
        Node<T> left;

        /** Pointer to the right child of this node. */
        Node<T> right;

        /** Pointer to the parent of this node. */
        Node<T> parent;

        /**
         * Creates a new Node with the passed {@code value}.
         *
         * @param value
         *          The value hold by the newly created node.
         */
        Node(T value) {
            this.value = value;
        }

        /**
         * Returns the <em>balance</em> of this node, which is simply the
         * height of its right sub tree minored by the height of the left
         * sub tree.<p>
         * This value is essential for tree rotations that will stabilize the
         * tree after every operation if necessary.
         *
         * @return Returns the balance of this node.
         * @see AVLTree#rotate(Node, boolean)
         */
        int getBalance() {

            if ((left == null) && (right == null)) {
                return 0;
            }

            final int lbal = (left == null) ? 0 : left.getHeight();
            final int rbal = (right == null) ? 0 : right.getHeight();
            return rbal - lbal;
        }

        /**
         * Returns the height of this node in the surrounding tree.
         *
         * @return Returns the height of this node in the surrounding tree.
         */
        int getHeight() {
            
            if ((left == null) && (right == null)) {
                /*
                 * Note that for calculating purposes the minimum height in a
                 * tree is 1, not 0.
                 */
                return 1;
            }

            final int lh = (left == null) ? 0 : left.getHeight();
            final int rh = (right == null) ? 0 : right.getHeight();
            return 1 + Math.max(lh, rh);
        }

        /**
         * Returns a string representation of this node by listing up the value
         * of this node. On the left and the right handside of this value all
         * children are listed up including their own values.
         *
         * @return Returns a string representation of this node.
         */
        @Override
        public String toString() {
            StringBuilder repr = new StringBuilder();

            if (left != null) {
                repr.append("(");
                repr.append(left.toString());
                repr.append(")");
            }

            if (value != null) {
                repr.append("[");
                repr.append(value);
                repr.append("]");
            }

            if (right != null) {
                repr.append("(");
                repr.append(right.toString());
                repr.append(")");
            }

            return repr.toString();
        }
    }

    /**
     * Main method that includes some testing.
     *
     * @param args
     *         Command line arguments (not used here).
     */
    public static void main(String[] args) {
        System.out.print("Creating tree ... ");
        AVLTree<Integer> tree = new AVLTree<>();
        System.out.println("done.");

        System.out.print("Provocating rotation ... ");
        tree.insert(-42);
        tree.insert(7);
        tree.insert(999);
        System.out.println("done.");
        System.out.println("Actual tree:\n");
        System.out.println(tree);

        System.out.print("Provocating second rotation ... ");
        tree.insert(10);
        tree.insert(144);
        System.out.println("done.");
        System.out.println("Actual tree:\n");
        System.out.println(tree);

        System.out.print("Provocating third rotation and root changing ... ");
        tree.insert(9);
        System.out.println("done.");
        System.out.println("Actual tree:\n");
        System.out.println(tree);

        System.out.print("Does the tree contain '999'? -> ");
        System.out.println(tree.contains(999));
        System.out.println();

        System.out.print("Deleting root ... ");
        tree.remove(10);
        System.out.println("done.");
        System.out.print("Deleting nodes '-42', '7' ... ");
        tree.remove(-42);
        tree.remove(7);
        System.out.println("done.");
        System.out.println();

        System.out.println();
        System.out.print("Does the tree contain '-42'? -> ");
        System.out.println(tree.contains(-42));
        System.out.println();

        System.out.println("Actual tree:\n");
        System.out.println(tree);
        
        System.out.println();
        System.out.print("Clearing tree ... ");
        tree.clear();
        System.out.println("done.");
        System.out.println("Tree should be empty now: " + tree.isEmpty());
    }
}
